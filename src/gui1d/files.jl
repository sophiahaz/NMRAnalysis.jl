"""
    loadregions!(expt::Experiment1D)

Load region definitions from a file.
"""
function loadregions!(expt::Experiment1D)
    file = pick_file(; filterlist="regions;txt")
    file == "" && return

    @info "Loading regions file $file"
    
    # Disable fitting temporarily
    isfitting = expt.isfitting[]
    if isfitting
        expt.isfitting[] = false
    end
    
    # Clear existing regions
    deleteallregions!(expt)
    
    # Read regions
    readregionlist!(expt, file)
    
    # Restore fitting status
    expt.isfitting[] = isfitting
    
    return expt
end

"""
    saveresults!(expt::Experiment1D)

Save analysis results to a folder.
"""
function saveresults!(expt::Experiment1D)
    folder = pick_folder()
    folder == "" && return

    @info "Saving results to $folder"
    
    @async begin
        expt.state[][:mode][] = :fitting
        sleep(0.1) # Allow time for mode change to be processed
    end
    
    @async begin # Do saving in a separate task
        sleep(0.2) # Allow time for mode change to be processed

        # Save region definitions
        writeregionlist!(expt, folder)
        
        # Save fit parameters to separate file
        writefitresults!(expt, folder)
        
        # Remove any existing plot files from the output folder
        for file in readdir(folder)
            if occursin(r"^region_.*\.(pdf|png)$", file) || 
               occursin(r"^overview\.(pdf|png)$", file)
                rm(joinpath(folder, file))
            end
        end
        
        # Save plots
        save_results_plots!(expt, folder)
        
        # Additional experiment-specific saving
        save_experiment_results!(expt, folder)
        
        expt.state[][:mode][] = :normal
    end
end

"""
    save_experiment_results!(expt::Experiment1D, folder)

Save additional experiment-specific results. Should be implemented by each experiment type.
"""
function save_experiment_results!(expt::Experiment1D, folder)
    # Default implementation - no additional saving
    # This should be overridden by specific experiment types
end

"""
    readregionlist!(expt::Experiment1D, filepath::AbstractString)

Read a regions list file and add regions to the experiment.
"""
function readregionlist!(expt::Experiment1D, filepath::AbstractString)
    region_count = 0

    open(filepath) do f
        for (line_number, line) in enumerate(eachline(f))
            # Skip empty lines and comments
            isempty(strip(line)) && continue
            startswith(strip(line), '#') && continue

            try
                fields = split(strip(line))
                if length(fields) < 3
                    throw(ArgumentError("Line $line_number: Insufficient fields"))
                end

                label = string(fields[1])  # Ensure string type
                xstart = parse(Float64, fields[2])
                xend = parse(Float64, fields[3])

                # Create region
                region = Region(xstart, xend, label)
                
                # Add additional parameters if present
                if length(fields) > 3
                    # Process additional fields
                    # This would depend on the specific format used
                end
                
                # Add region to experiment
                push!(expt.regions[], region)
                region_count += 1
                
                # Set up region parameters based on experiment type
                setup_region_parameters!(region, expt)

            catch e
                if e isa ArgumentError
                    @warn "Skipping line $line_number: $(e.msg)"
                else
                    rethrow()
                end
            end
        end
    end

    @debug "Added $region_count regions from $filepath"
    expt.state[][:total_regions][] = region_count
    notify(expt.regions)
    
    # Integrate regions
    integrate!(expt)
    
    return region_count
end

"""
    writeregionlist!(expt::Experiment1D, folder)

Write region definitions to a file.
"""
function writeregionlist!(expt::Experiment1D, folder)
    filepath = joinpath(folder, "regions.txt")
    backup_file(filepath)

    open(filepath, "w") do f
        # Write header
        println(f, "# Regions file")
        println(f, "# Format: label xstart xend")
        println(f, "# Generated by NMRAnalysis.jl")
        println(f, "#")
        
        for line in split(experimentinfo(expt), '\n')
            println(f, "# ", line)
        end
        
        println(f, "#")
        println(f, "# label\txstart\txend")
        
        # Write regions
        for region in expt.regions[]
            println(f, join([
                region.label[],
                round(region.xstart[], digits=6),
                round(region.xend[], digits=6)
            ], "\t"))
        end
    end
    
    return filepath
end

"""
    writefitresults!(expt::Experiment1D, folder)

Write fit results to a file.
"""
function writefitresults!(expt::Experiment1D, folder)
    filepath = joinpath(folder, "fit-results.txt")
    backup_file(filepath)

    open(filepath, "w") do f
        # Write header
        println(f, "# Fit results")
        println(f, "# Generated by NMRAnalysis.jl")
        println(f, "#")
        
        for line in split(experimentinfo(expt), '\n')
            println(f, "# ", line)
        end
        
        println(f, "#")
        
        # Create header line with parameter names
        if nregions(expt) > 0
            # Get parameter names from first region
            param_names = collect(keys(first(expt.regions[]).postparameters))
            
            # Build header
            header = ["label", "xstart", "xend"]
            
            for param in param_names
                param_label = replace(string(param), "_" => " ")
                push!(header, "$(param_label)_value", "$(param_label)_uncertainty")
            end
            
            println(f, "# ", join(header, "\t"))
            
            # Write data for each region
            for region in expt.regions[]
                # Basic region info
                values = [
                    region.label[],
                    round(region.xstart[], digits=6),
                    round(region.xend[], digits=6)
                ]
                
                # Add parameter values and uncertainties
                for param in param_names
                    if region.postfitted[] && haskey(region.postparameters, param)
                        push!(values, round(region.postparameters[param].value[][1], digits=8))
                        push!(values, round(region.postparameters[param].uncertainty[][1], digits=8))
                    else
                        push!(values, "NaN", "NaN")
                    end
                end
                
                println(f, join(values, "\t"))
            end
        else
            println(f, "# No regions defined")
        end
    end
    
    return filepath
end

"""
    backup_file(filepath::AbstractString)

Create a backup of an existing file by appending '.old'.
"""
function backup_file(filepath::AbstractString)
    isfile(filepath) || return
    backup_path = filepath * ".old"
    @debug "Backing up $filepath to $backup_path"
    return mv(filepath, backup_path; force=true)
end

"""
    save_diffusion_results!(expt::DiffusionExperiment, folder)

Save additional results specific to diffusion experiments.
"""
function save_experiment_results!(expt::DiffusionExperiment, folder)
    # Save detailed diffusion parameters
    filepath = joinpath(folder, "diffusion-parameters.txt")
    
    open(filepath, "w") do f
        println(f, "# Diffusion Parameters")
        println(f, "# Generated by NMRAnalysis.jl")
        println(f, "#")
        
        # Write experiment parameters
        println(f, "Gradient pulse length (δ): $(expt.δ * 1e6) μs")
        println(f, "Diffusion delay (Δ): $(expt.Δ * 1e3) ms")
        println(f, "Shape factor (σ): $(expt.σ)")
        println(f, "Gyromagnetic ratio (γ): $(expt.γ * 1e-6) MHz/T")
        println(f, "Solvent: $(isnothing(expt.solvent) ? "unknown" : expt.solvent)")
        println(f, "Temperature: $(expt.temperature) K")
        println(f, "#")
        
        # Write gradient list
        println(f, "# Gradient list (T/m)")
        for (i, g) in enumerate(expt.gradients)
            println(f, "$i\t$g")
        end
        println(f, "#")
        
        # Write integration data for each region
        println(f, "# Region integration data")
        println(f, "# Format: gradient_idx\tgradient\tregion1\tregion1_error\tregion2\t...")
        
        # Header with region labels
        header = ["idx", "gradient"]
        for region in expt.regions[]
            push!(header, region.label[], "$(region.label[])_error")
        end
        println(f, "# ", join(header, "\t"))
        
        # Data rows
        for i in 1:length(expt.gradients)
            row = [i, expt.gradients[i]]
            
            for region in expt.regions[]
                integrals = region.parameters[:integral].value[]
                errors = region.parameters[:error].value[]
                
                if i <= length(integrals) && i <= length(errors)
                    push!(row, integrals[i], errors[i])
                else
                    push!(row, "NaN", "NaN")
                end
            end
            
            println(f, join(row, "\t"))
        end
    end
end

"""
    save_tract_results!(expt::TRACTExperiment, folder)

Save additional results specific to TRACT experiments.
"""
function save_experiment_results!(expt::TRACTExperiment, folder)
    # Save detailed TRACT parameters
    filepath = joinpath(folder, "tract-parameters.txt")
    
    open(filepath, "w") do f
        println(f, "# TRACT Parameters")
        println(f, "# Generated by NMRAnalysis.jl")
        println(f, "#")
        
        # Write experiment parameters
        println(f, "Field strength: $(expt.field_strength) T")
        println(f, "Temperature: $(expt.temperature) K")
        println(f, "#")
        
        # Write relaxation time lists
        println(f, "# TROSY relaxation times (s)")
        for (i, t) in enumerate(expt.τ_trosy)
            println(f, "$i\t$t")
        end
        println(f, "#")
        
        println(f, "# Anti-TROSY relaxation times (s)")
        for (i, t) in enumerate(expt.τ_antitrosy)
            println(f, "$i\t$t")
        end
        println(f, "#")
        
        # Write integration data for each region
        println(f, "# Region TROSY integration data")
        println(f, "# Format: time_idx\ttime\tregion1\tregion1_error\tregion2\t...")
        
        # Header with region labels for TROSY
        header = ["idx", "time"]
        for region in expt.regions[]
            push!(header, region.label[], "$(region.label[])_error")
        end
        println(f, "# ", join(header, "\t"))
        
        # TROSY data rows
        for i in 1:length(expt.τ_trosy)
            row = [i, expt.τ_trosy[i]]
            
            for region in expt.regions[]
                integrals = region.parameters[:integral_trosy].value[]
                errors = region.parameters[:error_trosy].value[]
                
                if i <= length(integrals) && i <= length(errors)
                    push!(row, integrals[i], errors[i])
                else
                    push!(row, "NaN", "NaN")
                end
            end
            
            println(f, join(row, "\t"))
        end
        
        println(f, "#")
        println(f, "# Region Anti-TROSY integration data")
        println(f, "# Format: time_idx\ttime\tregion1\tregion1_error\tregion2\t...")
        
        # Header with region labels for Anti-TROSY
        println(f, "# ", join(header, "\t"))
        
        # Anti-TROSY data rows
        for i in 1:length(expt.τ_antitrosy)
            row = [i, expt.τ_antitrosy[i]]
            
            for region in expt.regions[]
                integrals = region.parameters[:integral_antitrosy].value[]
                errors = region.parameters[:error_antitrosy].value[]
                
                if i <= length(integrals) && i <= length(errors)
                    push!(row, integrals[i], errors[i])
                else
                    push!(row, "NaN", "NaN")
                end
            end
            
            println(f, join(row, "\t"))
        end
    end
end